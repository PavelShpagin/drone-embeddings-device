#!/usr/bin/env python3
"""
FastAPI server for drone device management with web UI.
Provides map interface for mission configuration and state management.
"""

import asyncio
import json
import logging
import os
import shutil
import time
import uuid
import zipfile
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional

import yaml
from fastapi import FastAPI, HTTPException, Request, BackgroundTasks
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

# Add device src to path
import sys
device_src_path = str(Path(__file__).parent / 'src')
sys.path.insert(0, device_src_path)
sys.path.insert(0, str(Path(__file__).parent / 'src' / 'general'))

from src.device.init_map_wrapper import call_server_init_map

# Logging setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Drone Device Server", description="Global UAV Localization Device Interface")

# Global state for tracking async tasks
active_tasks = {}
progress_data = {}


class InitMapRequest(BaseModel):
    lat: float
    lng: float
    km: float
    session_id: Optional[str] = None


class StateManager:
    """Manages device state in YAML file."""
    
    def __init__(self, state_file: str = "state.yaml"):
        self.state_file = Path(state_file)
        self.ensure_state_file()
    
    def ensure_state_file(self):
        """Create state file if it doesn't exist."""
        if not self.state_file.exists():
            default_state = {
                'session_id': '',
                'lat': None,
                'lng': None,
                'km': None,
                'last_updated': None
            }
            self.save_state(default_state)
    
    def load_state(self) -> Dict[str, Any]:
        """Load state from YAML file."""
        try:
            with open(self.state_file, 'r') as f:
                return yaml.safe_load(f) or {}
        except Exception as e:
            logger.error(f"Error loading state: {e}")
            return {}
    
    def save_state(self, state: Dict[str, Any]):
        """Save state to YAML file."""
        try:
            state['last_updated'] = datetime.now().isoformat()
            with open(self.state_file, 'w') as f:
                yaml.dump(state, f, default_flow_style=False)
        except Exception as e:
            logger.error(f"Error saving state: {e}")
    
    def update_state(self, **kwargs):
        """Update specific state fields."""
        state = self.load_state()
        state.update(kwargs)
        self.save_state(state)
    
    def get_computed_status(self) -> str:
        """Compute status based on session_id: empty = idle, non-empty = ready."""
        state = self.load_state()
        session_id = state.get('session_id', '')
        return 'ready' if session_id else 'idle'
    
    def load_state_with_status(self) -> Dict[str, Any]:
        """Load state with computed status."""
        state = self.load_state()
        state['status'] = self.get_computed_status()
        return state


# Initialize state manager
state_manager = StateManager()


@app.get("/", response_class=HTMLResponse)
async def get_index():
    """Serve the main HTML interface."""
    html_content = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global UAV Localization</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBQEoMxbEzfrLNK2L69c7J6HeS5GJG-Uis&libraries=places"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap');
        
        :root {
            --primary-blue: #1e40af;
            --accent-yellow: #fbbf24;
            --success-green: #10b981;
            --danger-red: #ef4444;
            --neutral-gray: #6b7280;
            --light-gray: #f3f4f6;
            --white: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--white);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            color: #333;
        }
        
        .container {
            width: 100%;
            height: 100vh;
            background: var(--white);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: var(--primary-blue);
            color: var(--white);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo {
            width: 36px;
            height: 36px;
        }
        
        .header h1 {
            font-size: 20px;
            font-weight: 700;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            height: calc(100vh - 66px);
        }
        
        .sidebar {
            width: 350px;
            background: var(--light-gray);
            padding: 16px;
            border-right: 1px solid #e5e7eb;
            overflow-y: auto;
        }
        
        .state-box {
            background: var(--white);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .state-box h3 {
            color: var(--primary-blue);
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .state-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .state-label {
            color: var(--neutral-gray);
            font-weight: 500;
        }
        
        .state-value {
            font-weight: 700;
            color: #333;
        }
        
        .controls {
            margin-top: 14px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--neutral-gray);
            font-size: 14px;
        }
        
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: var(--primary-blue);
        }
        
        .search-input-container {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            color: var(--neutral-gray);
            z-index: 1;
            pointer-events: none;
        }
        
        .search-input-container input {
            padding-left: 40px;
        }
        
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 500;
            font-size: 14px;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: var(--success-green);
            color: var(--white);
        }
        
        .btn-primary:hover {
            background: #059669;
        }
        
        .btn-danger {
            background: var(--danger-red);
            color: var(--white);
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .btn-secondary {
            background: var(--neutral-gray);
            color: var(--white);
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }

        
        .btn-discovery {
            background: #f59e0b;
            color: var(--white);
            font-weight: 500;
        }
        
        .btn-discovery:hover {
            background: #d97706;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
            min-height: 600px;
        }
        
        .progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .progress-content {
            text-align: center;
            width: 360px; /* slightly thinner */
            max-width: 90vw;
            padding: 40px;
            background: var(--white);
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--success-green);
            width: 0%;
        }
        
        /* Manual session row */
        .manual-session-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .manual-session-row input {
            flex: 1 1 auto;
            min-width: 0;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
        }
        .btn-blue {
            background: #3b7dd8; /* improved natural blue */
            color: var(--white);
        }
        .btn-blue:hover {
            background: #1d4ed8; /* richer blue on hover */
        }
        
        .status-text {
            color: var(--neutral-gray);
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .timer {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary-blue);
            margin: 10px 0;
        }
        

        
        .hidden {
            display: none !important;
        }
        
        .btn-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }
        
        .btn-group .btn {
            flex: 1;
            min-height: 48px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 66px);
            }
            
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e5e7eb;
                order: 1;
            }
            
            .map-container {
                order: 2;
                min-height: 400px;
                flex: 1;
            }
            
            .header {
                padding: 12px 20px;
            }
            
            .header h1 {
                font-size: 18px;
            }
            
            .logo {
                width: 32px;
                height: 32px;
            }
            
            .sidebar {
                padding: 20px;
            }
            
            .input-group {
                margin-bottom: 15px;
            }
            
            .btn-group {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn-group .btn {
                width: 100%;
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="/static/favicon.png" alt="Logo" class="logo">
            <h1>Global UAV Localization</h1>
        </div>
        
        <div class="main-content">
            <div class="sidebar">
                <div class="state-box">
                    <h3>Drone State</h3>
                    <div id="state-content">
                        <!-- State will be populated by JavaScript -->
                    </div>

                    <button class="btn btn-danger" onclick="clearState()" style="width: 100%; margin-top: 12px;">
                        Clear State
                    </button>
                </div>
                
                <div class="controls">
                    <div class="input-group">
                        <label>Search Location</label>
                        <div class="search-input-container">
                            <svg class="search-icon" viewBox="0 0 24 24" width="16" height="16">
                                <path fill="currentColor" d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                            </svg>
                            <input type="text" id="search-input" placeholder="Search for a place...">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Latitude</label>
                        <input type="number" id="lat-input" step="any" placeholder="50.4162">
                    </div>
                    
                    <div class="input-group">
                        <label>Longitude</label>
                        <input type="number" id="lng-input" step="any" placeholder="30.8906">
                    </div>
                    
                    <div class="input-group">
                        <label>Coverage (km)</label>
                        <input type="number" id="km-input" min="1" max="100" value="1" placeholder="1">
                    </div>
                    
                    <!-- Fetch Existing Session -->
                    <div id="manual-session" style="margin-top: 15px; margin-bottom: 15px;">
                        <div class="manual-session-row">
                            <input id="session-input" type="text" maxlength="8" placeholder="8-char session id" />
                            <button class="btn btn-blue" id="fetch-session-btn" onclick="fetchExistingSession()">Fetch</button>
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" id="submit-btn" onclick="submitMission()" style="width: 100%;">
                        Submit Mission
                    </button>
                    

                    
                    <button class="btn btn-discovery" id="discovery-btn" onclick="startDiscovery()" style="width: 100%; margin-top: 15px;">
                        Find Drones
                    </button>
                    
                    <button class="btn btn-secondary" id="send-logs-btn" onclick="sendLogs()" style="width: 100%; margin-top: 15px;">
                        Send Logs
                    </button>
                </div>
            </div>
            
            <div class="map-container">
                <div id="map"></div>
                
                <div class="progress-overlay" id="progress-overlay">
                    <div class="progress-content">
                        <div class="status-text" id="status-text">Initializing...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                        <div class="timer" id="timer"></div>
                        <button class="btn btn-danger" id="cancel-progress-btn" onclick="immediateCancel()">
                            Cancel Operation
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let map;
        let marker;
        let currentState = {};
        let progressTimer;
        
        // Initialize Google Map
        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 50.4162, lng: 30.8906 },
                zoom: 10,
                mapTypeId: 'hybrid',
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: false
            });
            
            // Initialize search functionality
            const searchBox = new google.maps.places.SearchBox(document.getElementById('search-input'));
            
            // Bias the SearchBox results towards current map's viewport
            map.addListener('bounds_changed', function() {
                searchBox.setBounds(map.getBounds());
            });
            
            // Listen for the event fired when the user selects a prediction
            searchBox.addListener('places_changed', function() {
                const places = searchBox.getPlaces();
                
                if (places.length == 0) {
                    return;
                }
                
                // Get the first place
                const place = places[0];
                
                if (!place.geometry || !place.geometry.location) {
                    console.log("Returned place contains no geometry");
                    return;
                }
                
                // Center map on the selected place
                map.setCenter(place.geometry.location);
                map.setZoom(14);
                
                // Update coordinates
                const lat = place.geometry.location.lat();
                const lng = place.geometry.location.lng();
                
                document.getElementById('lat-input').value = lat.toFixed(6);
                document.getElementById('lng-input').value = lng.toFixed(6);
                
                // Update marker
                if (marker) {
                    marker.setPosition(place.geometry.location);
                } else {
                    marker = new google.maps.Marker({
                        position: place.geometry.location,
                        map: map,
                        title: place.name || 'Selected Location'
                    });
                }
            });
            
            // Add click listener for coordinate selection
            map.addListener('click', function(event) {
                const lat = event.latLng.lat();
                const lng = event.latLng.lng();
                
                // Update inputs
                document.getElementById('lat-input').value = lat.toFixed(6);
                document.getElementById('lng-input').value = lng.toFixed(6);
                
                // Update marker
                if (marker) {
                    marker.setPosition(event.latLng);
                } else {
                    marker = new google.maps.Marker({
                        position: event.latLng,
                        map: map,
                        title: 'Selected Location'
                    });
                }
            });
        }
        
        // Load current state
        async function loadState() {
            try {
                const response = await fetch('/api/state');
                currentState = await response.json();
                updateStateDisplay();
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }
        
        // Update state display
        function updateStateDisplay() {
            const stateContent = document.getElementById('state-content');
            const statusBadge = getStatusBadge(currentState.status || 'idle');
            const sessionDisplay = currentState.session_id || 'None';
            
            stateContent.innerHTML = `
                <div class="state-item">
                    <span class="state-label">Status:</span>
                    <span class="state-value">${statusBadge}</span>
                </div>
                <div class="state-item">
                    <span class="state-label">Session:</span>
                    <span class="state-value">${sessionDisplay}</span>
                </div>
                <div class="state-item">
                    <span class="state-label">Location:</span>
                    <span class="state-value">${currentState.lat && currentState.lng ? 
                        `${currentState.lat.toFixed(4)}, ${currentState.lng.toFixed(4)}` : 'Not Set'}</span>
                </div>
                <div class="state-item">
                    <span class="state-label">Coverage:</span>
                    <span class="state-value">${currentState.km ? currentState.km + ' km' : 'Not Set'}</span>
                </div>
            `;
        }
        
        // Get status badge with color
        function getStatusBadge(status) {
            const badges = {
                'idle': '<span style="color: var(--neutral-gray);">‚óè Idle</span>',
                'initializing': '<span style="color: var(--accent-yellow);">‚óè Initializing</span>',
                'ready': '<span style="color: var(--success-green);">‚óè Ready</span>',
                'processing': '<span style="color: var(--primary-blue);">‚óè Processing</span>',
                'error': '<span style="color: var(--danger-red);">‚óè Error</span>'
            };
            return badges[status] || badges['idle'];
        }
        
        // Button management functions
        function disableButtons() {
            document.getElementById('submit-btn').disabled = true;
            document.getElementById('discovery-btn').disabled = true;
            document.getElementById('send-logs-btn').disabled = true;
            document.getElementById('fetch-session-btn').disabled = true;
            
            // Also disable clear state button
            const clearBtn = document.querySelector('.state-box button');
            if (clearBtn) clearBtn.disabled = true;
        }
        
        function enableButtons() {
            document.getElementById('submit-btn').disabled = false;
            document.getElementById('discovery-btn').disabled = false;
            document.getElementById('send-logs-btn').disabled = false;
            document.getElementById('fetch-session-btn').disabled = false;
            
            // Re-enable clear state button
            const clearBtn = document.querySelector('.state-box button');
            if (clearBtn) clearBtn.disabled = false;
        }
        
        // Fetch existing session function
        async function fetchExistingSession() {
            const sessionInput = document.getElementById('session-input');
            const sessionId = sessionInput.value.trim();
            
            // Validate session ID format (8 characters, alphanumeric)
            if (!/^[a-zA-Z0-9]{8}$/.test(sessionId)) {
                alert('Please enter a valid 8-character session ID (letters and numbers only)');
                return;
            }
            
            // Disable buttons during fetch
            disableButtons();
            showProgress('Fetching session data...', 0);
            
            try {
                const response = await fetch('/api/fetch_session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    hideProgress();
                    enableButtons();
                    if (response.status === 404) {
                        alert('Session not found. Please check the session ID and try again.');
                    } else {
                        alert(data.message || 'Failed to fetch session data');
                    }
                    return;
                }
                
                // Start polling for progress
                pollProgress();
                
            } catch (error) {
                hideProgress();
                enableButtons();
                alert('Network error. Please check your connection and try again.');
            }
        }
        

        
        function toggleSessionPanel(open) {
            const panel = document.getElementById('session-panel');
            if (!panel) return;
            if (open === false) { panel.style.display = 'none'; return; }
            panel.style.display = (panel.style.display === 'none' || !panel.style.display) ? 'block' : 'none';
        }
        
        async function submitExistingSession() {
            const input = document.getElementById('session-input');
            const err = document.getElementById('session-error');
            if (!input || !err) return;
            const sid = (input.value || '').trim();
            err.textContent = '';
            if (!/^([a-z0-9]{8})$/.test(sid)) {
                err.textContent = 'Please enter a valid 8-character session ID (a-z, 0-9).';
                return;
            }
            disableButtons();  
            showProgress('Preparing data...', unifiedProgress);
            try {
                const res = await fetch('/api/init_map', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lat: currentState.lat || 0, lng: currentState.lng || 0, km: currentState.km || 1, session_id: sid })
                });
                const data = await res.json();
                if (!res.ok || (data && data.status === 'error')) {
                    err.textContent = (data && data.message) ? data.message : 'Failed to fetch session.';
                    enableButtons();
                    return;
                }
                pollProgress();
            } catch (e) {
                err.textContent = 'Network error fetching session.';
                enableButtons();
            }
        }
        
        // Submit mission
        async function submitMission() {
            const lat = parseFloat(document.getElementById('lat-input').value);
            const lng = parseFloat(document.getElementById('lng-input').value);
            const km = parseFloat(document.getElementById('km-input').value);
            
            if (!lat || !lng || !km) {
                alert('Please fill in all coordinates and coverage area');
                return;
            }
            
            try {
                disableButtons();
                showProgress('Submitting mission...', 0);
                
                const response = await fetch('/api/init_map', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lat, lng, km })
                });
                
                if (response.ok) {
                    pollProgress();
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    hideProgress();
                    enableButtons();
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
                hideProgress();
                enableButtons();
            }
        }
        
        // Send logs
        async function sendLogs() {
            try {
                disableButtons();
                showProgress('Sending logs...', 0);
                
                const response = await fetch('/api/send_logs', { method: 'POST' });
                
                if (response.ok) {
                    pollProgress();
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    hideProgress();
                    enableButtons();
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
                hideProgress();
                enableButtons();
            }
        }
        
        // Clear state
        async function clearState() {
            if (confirm('Are you sure you want to clear all drone state?')) {
                try {
                    const response = await fetch('/api/clear_state', { method: 'POST' });
                    if (response.ok) {
                        loadState();
                    } else {
                        alert('Error clearing state');
                    }
                } catch (error) {
                    alert(`Network error: ${error.message}`);
                }
            }
        }
        
        // Immediate cancel with instant UI reset - make it globally accessible
        window.immediateCancel = function() {
            console.log('Cancel button clicked - immediate UI reset');
            
            // 1. STOP POLLING IMMEDIATELY to reduce browser lag
            if (progressTimer) {
                clearInterval(progressTimer);
                progressTimer = null;
                console.log('üõë Stopped progress polling immediately');
            }
            
            // 2. IMMEDIATE UI RESET - no delays, no waiting
            hideProgress();
            enableButtons(); 
            loadState();
            console.log('‚úÖ UI immediately restored');
            
            // 3. Start background cancellation & cleanup (fire-and-forget)
            // Don't await or block on this - UI is already restored
            setTimeout(() => {
                cancelOperationBackground().catch(err => {
                    console.log('Background cancellation completed (error ignored):', err);
                });
            }, 0); // Execute in next tick to avoid blocking
        };
        
        // Quick file cleanup (non-blocking)
        async function quickFileCleanup() {
            try {
                console.log('Starting quick file cleanup...');
                // Call server to clean up any partial files
                await fetch('/api/cleanup_partial_files', { method: 'POST' });
                console.log('Quick cleanup completed');
            } catch (error) {
                console.log('Cleanup completed (may have been nothing to clean)');
            }
        }
        
        // Background cancel operation (doesn't block UI)
        async function cancelOperationBackground() {
            console.log('üîÑ Starting background cancellation...');
            try {
                const progress = await fetch('/api/progress').then(r => r.json());
                
                if (progress.message && progress.message.includes('Looking for other drones')) {
                    console.log('üõë Stopping discovery operation...');
                    await fetch('/api/stop_discovery', { method: 'POST' });
                } else {
                    console.log('üõë Aborting WebSocket & cleanup...');
                    
                    // Abort WebSocket connection (don't update UI - it's already hidden)
                    try {
                        const wsResult = await fetch('/api/abort_websocket', { method: 'POST' });
                        const wsData = await wsResult.json();
                        console.log('‚úÖ WebSocket abort result:', wsData.status);
                    } catch (wsError) {
                        console.log('‚ö†Ô∏è WebSocket abort failed (ignored):', wsError.message);
                    }
                    
                    // Also call regular abort as fallback
                    console.log('üõë Calling regular abort API...');
                    await fetch('/api/abort', { method: 'POST' });
                    console.log('‚úÖ Background cleanup complete');
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Background cancellation error (ignored):', error.message);
            }
        }
        
        // Show progress overlay
        // Unified progress state (persists across phases)
        let unifiedProgress = 0;
        function showProgress(status, progress, timer = null) {
            document.getElementById('progress-overlay').style.display = 'flex';
            // Do not reset bar; only move forward
            unifiedProgress = Math.max(unifiedProgress, Number(progress) || 0);
            updateProgress(status, unifiedProgress, timer);
        }
        
        // Update progress
        function updateProgress(status, progress, timer = null) {
            // Coerce numeric progress and clamp range
            unifiedProgress = Math.max(unifiedProgress, Number(progress) || 0);
            const p = Math.max(0, Math.min(100, unifiedProgress));
            // Map verbose messages to short generic ones
            const genericMap = [
                [/initializing|requesting|connecting/i, 'Preparing data...'],
                [/download|tile|satellite|stitch/i, 'Preparing data...'],
                [/process|generat|embed|compute/i, 'Processing data...'],
                [/packag|save|finaliz|compress/i, 'Finalizing...'],
                [/ready|complete/i, 'Finished']
            ];
            let cleanStatus = (status || '').replace(/\\s*\\(\\d+s\\s*remaining\\)/, '').replace(/\\s*\\(\\d+s\\)/, '');
            for (const [re, txt] of genericMap) { if (re.test(cleanStatus)) { cleanStatus = txt; break; } }
            document.getElementById('status-text').textContent = cleanStatus;
            document.getElementById('progress-fill').style.width = `${p}%`;
            
            if (timer !== null) {
                document.getElementById('timer').textContent = `${timer}s`;
            } else {
                document.getElementById('timer').textContent = '';
            }
        }
        
        // Hide progress overlay
        function hideProgress() {
            document.getElementById('progress-overlay').style.display = 'none';
            
            if (progressTimer) {
                clearInterval(progressTimer);
                progressTimer = null;
            }
            // Reset unified bar only when fully closed
            unifiedProgress = 0;
        }
        
        // Poll for progress updates
        function pollProgress() {
            let pollCount = 0;
            let idleCount = 0; // Track consecutive idle responses
            const maxPollsWithoutChange = 30; // 30 seconds without change = timeout
            const maxIdleBeforeClose = 3; // Allow 3 consecutive idle responses before closing
            let lastMessage = '';
            
            progressTimer = setInterval(async () => {
                try {
                    const response = await fetch('/api/progress');
                    const data = await response.json();
                    
                    pollCount++;
                    
                    // Handle idle status with grace period to prevent premature closing
                    if (data.status === 'idle') {
                        idleCount++;
                        console.log(`Operation idle (${idleCount}/${maxIdleBeforeClose})`);
                        
                        // Only close after multiple consecutive idle responses
                        if (idleCount >= maxIdleBeforeClose) {
                            console.log('Operation confirmed idle - resetting UI');
                            clearInterval(progressTimer);
                            progressTimer = null;
                            hideProgress();
                            enableButtons();
                            loadState();
                            return;
                        }
                    } else {
                        // Reset idle counter if we get any non-idle response
                        idleCount = 0;
                    }
                    
                    // Detect if we're stuck with same message for too long
                    if (data.message === lastMessage) {
                        if (pollCount > maxPollsWithoutChange) {
                            console.log('Progress polling timeout - resetting UI');
                            clearInterval(progressTimer);
                            progressTimer = null;
                            hideProgress();
                            enableButtons();
                            loadState();
                            return;
                        }
                    } else {
                        pollCount = 0; // Reset counter on any change
                        lastMessage = data.message;
                    }
                    
                    if (data.status === 'complete') {
                        updateProgress(data.message, data.progress, data.timer);
                        // Stop polling immediately to prevent idle status
                        clearInterval(progressTimer);
                        progressTimer = null;
                        
                        // Check if this is a fetch session completion
                        const sessionPanel = document.getElementById('session-panel');
                        const sessionError = document.getElementById('session-error');
                        
                        if (sessionPanel && sessionPanel.style.display !== 'none') {
                            // This is a fetch session completion - close panel and hide progress
                            setTimeout(() => {
                                hideProgress();
                                enableButtons();
                                sessionPanel.style.display = 'none';
                                if (sessionError) sessionError.textContent = '';
                                loadState();
                            }, 1500);  // Brief moment to show completion message
                        } else {
                            // Regular operation completion
                            setTimeout(() => {
                                hideProgress();
                                enableButtons();
                                loadState();
                            }, 1500);  // Brief moment to show completion message
                        }
                    } else if (data.status === 'error') {
                        // Check if this is a fetch_session error
                        const sessionPanel = document.getElementById('session-panel');
                        const sessionError = document.getElementById('session-error');
                        
                        if (sessionPanel && sessionPanel.style.display !== 'none' && sessionError) {
                            // This is a fetch session error - show in panel
                            sessionError.textContent = data.message || 'Session not found';
                            clearInterval(progressTimer);
                            progressTimer = null;
                            hideProgress();
                            enableButtons();
                            // Don't reload state, keep panel open for retry
                        } else {
                            // Regular operation error - show alert
                            alert(`Operation failed: ${data.message}`);
                            clearInterval(progressTimer);
                            progressTimer = null;
                            hideProgress();
                            enableButtons();
                            loadState();
                        }
                    } else if (data.status === 'cancelled') {
                        updateProgress(data.message, data.progress, data.timer);
                        clearInterval(progressTimer);
                        progressTimer = null;
                        setTimeout(() => {
                            hideProgress();
                            enableButtons();
                            loadState();
                        }, 1500);  // Brief delay to show "Cleaning up..." message
                    } else if (!data.status) {
                        // Backend operation with no status - reset UI
                        console.log('No status received - resetting UI');
                        clearInterval(progressTimer);
                        progressTimer = null;
                        hideProgress();
                        enableButtons();
                        loadState();
                    } else {
                        updateProgress(data.message, data.progress, data.timer);
                    }
                } catch (error) {
                    console.error('Error polling progress:', error);
                }
            }, 1000);
        }
        
        // Manual discovery function
        async function startDiscovery() {
            try {
                disableButtons();
                showProgress('Looking for other drones...', 0, 30);
                
                const response = await fetch('/api/start_discovery', { method: 'POST' });
                if (response.ok) {
                    pollProgress();
                } else {
                    const error = await response.json();
                    alert(`Error: ${error.detail}`);
                    hideProgress();
                    enableButtons();
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
                hideProgress();
                enableButtons();
            }
        }
        
        // Initialize on page load
        window.onload = function() {
            initMap();
            loadState();
            
            // Refresh state every 5 seconds
            setInterval(loadState, 5000);
        };

        // Event delegation for cancel button (more reliable than onclick)
        document.addEventListener('click', function(e) {
            if (e.target && e.target.id === 'cancel-progress-btn') {
                e.preventDefault();
                e.stopPropagation();
                console.log('Cancel button clicked via event delegation');
                window.immediateCancel();
            }
        });

        // Keyboard shortcuts for testing via MCP
        document.addEventListener('keydown', function(e) {
            try {
                if (e.key === 'Escape') {
                    // Cancel current operation with immediate UI reset
                    window.immediateCancel();
                } else if ((e.key || '').toLowerCase() === 'd') {
                    // Start discovery (shows overlay and cancel button)
                    startDiscovery();
                }
            } catch (err) {
                console.error('Shortcut handler error:', err);
            }
        });
    </script>
</body>
</html>
"""
    return HTMLResponse(content=html_content)


@app.get("/static/favicon.png")
async def get_favicon():
    """Serve the favicon."""
    favicon_path = Path(__file__).parent / "server" / "favicon.png"
    if favicon_path.exists():
        return FileResponse(favicon_path)
    raise HTTPException(status_code=404, detail="Favicon not found")


@app.get("/api/state")
async def get_state():
    """Get current drone state with computed status."""
    return state_manager.load_state_with_status()


@app.post("/api/init_map")
async def init_map(request: InitMapRequest, background_tasks: BackgroundTasks):
    """Initialize map data for given coordinates."""
    global active_tasks, progress_data
    
    # Cancel any existing task
    if 'init_map' in active_tasks:
        active_tasks['init_map'].cancel()
    
    # Start new background task
    task_id = str(uuid.uuid4())
    active_tasks['init_map'] = asyncio.create_task(
        _init_map_background(request.lat, request.lng, request.km, task_id)
    )
    
    return {"status": "started", "task_id": task_id}


@app.post("/api/send_logs")
async def send_logs(background_tasks: BackgroundTasks):
    """Send logs to server."""
    global active_tasks, progress_data
    
    # Cancel any existing task
    if 'send_logs' in active_tasks:
        active_tasks['send_logs'].cancel()
    
    # Start new background task
    task_id = str(uuid.uuid4())
    active_tasks['send_logs'] = asyncio.create_task(
        _send_logs_background(task_id)
    )
    
    return {"status": "started", "task_id": task_id}


@app.post("/api/clear_state")
async def clear_state():
    """Clear all state and local data."""
    try:
        # Clear state file
        default_state = {
            'session_id': '',
            'lat': None,
            'lng': None,
            'km': None,
            'last_updated': None
        }
        state_manager.save_state(default_state)
        
        # Clean up local data directories
        data_dir = Path("data")
        for subdir in ["maps", "embeddings"]:
            subdir_path = data_dir / subdir
            if subdir_path.exists():
                shutil.rmtree(subdir_path)
                subdir_path.mkdir(parents=True, exist_ok=True)
        
        # Remove sessions file
        sessions_file = data_dir / "sessions.pkl"
        if sessions_file.exists():
            sessions_file.unlink()
        
        return {"status": "success", "message": "State cleared"}
    
    except Exception as e:
        logger.error(f"Error clearing state: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/start_discovery")
async def start_discovery(background_tasks: BackgroundTasks):
    """Start drone discovery process."""
    global active_tasks, progress_data
    
    # Cancel any existing discovery task
    if 'discovery' in active_tasks:
        active_tasks['discovery'].cancel()
    
    # Start new discovery task
    task_id = str(uuid.uuid4())
    active_tasks['discovery'] = asyncio.create_task(
        _discovery_background(task_id)
    )
    
    return {"status": "discovery_started", "task_id": task_id}


@app.post("/api/stop_discovery")
async def stop_discovery():
    """Stop the discovery process."""
    global active_tasks, progress_data
    
    # Cancel discovery task
    if 'discovery' in active_tasks:
        active_tasks['discovery'].cancel()
        logger.info("Discovery cancelled by user")
    
    # Return to proper state based on actual data
    current_state = state_manager.load_state()
    session_id = current_state.get('session_id')
    
    if session_id:
        map_file = Path(f"data/maps/{session_id}.png")
        embeddings_file = Path(f"data/embeddings/{session_id}.json")
        
        if not (map_file.exists() and embeddings_file.exists()):
            # Session ID exists but no data files - reset to empty
            state_manager.update_state(session_id='')
    # Clear discovery progress
    if 'discovery' in progress_data:
        del progress_data['discovery']
    
    return {"status": "discovery_stopped"}


@app.post("/api/stop_listener")
async def stop_listener():
    """Stop the listener discovery process."""
    # This would signal the listener to stop discovery
    # State will be computed from session_id automatically
    return {"status": "listener_stopped"}


@app.post("/api/abort")
async def abort_operation():
    """Abort current operation."""
    global active_tasks, progress_data
    
    logger.info("=== ABORT OPERATION INITIATED ===")
    
    # IMMEDIATE UI FEEDBACK: Set cancellation status for any active operations
    current_operations = list(progress_data.keys())
    for operation in current_operations:
        if operation in progress_data:
            progress_data[operation] = {
                "status": "cancelled",
                "progress": 0,
                "message": "Cleaning up..."
            }
            logger.info(f"‚úì Set cancelled status for {operation}")
    
    # Handle WebSocket cancellation if in WebSocket mode
    websocket_operations = ['init_map', 'fetch_session']
    for operation in websocket_operations:
        if operation in current_operations and progress_data.get(operation, {}).get('websocket_mode'):
            try:
                # WebSocket operations not supported in current implementation
                cancelled = False
                if cancelled:
                    logger.info(f"‚úì WebSocket cancellation sent for {operation}")
                else:
                    logger.info(f"‚úó WebSocket cancellation failed for {operation}")
            except Exception as e:
                logger.error(f"WebSocket cancellation error for {operation}: {e}")
    
    # Cancel active tasks
    if active_tasks:
        logger.info(f"Active tasks to cancel: {list(active_tasks.keys())}")
        for task_name, task in active_tasks.items():
            if not task.done():
                task.cancel()
                logger.info(f"‚úì Cancelled task: {task_name}")
            else:
                logger.info(f"‚úì Task already done: {task_name}")
    else:
        logger.info("No active tasks to cancel")
    
    # The progress data will be cleaned up by the cancelled tasks themselves
    # Don't clear immediately - let the UI show "Cleaning up..." first
    
    logger.info("=== ABORT OPERATION COMPLETED ===")
    
    return {"status": "aborted"}


@app.post("/api/abort_websocket")
async def abort_websocket():
    """Immediately abort any active WebSocket connections."""
    global active_tasks, progress_data
    
    logger.info("=== WEBSOCKET ABORT INITIATED ===")
    
    try:
        # WebSocket operations not supported in current implementation
        result = False
        
        if result:
            logger.info("‚úì WebSocket connection forcefully closed")
            
            # Set immediate cancellation status for all operations
            current_operations = list(progress_data.keys())
            for operation in current_operations:
                if operation in progress_data:
                    progress_data[operation] = {
                        "status": "cancelled",
                        "progress": 0,
                        "message": "Connection aborted"
                    }
                    logger.info(f"‚úì Set aborted status for {operation}")
            
            # Cancel all active tasks immediately
            if active_tasks:
                for task_name, task in active_tasks.items():
                    if not task.done():
                        task.cancel()
                        logger.info(f"‚úì Force cancelled task: {task_name}")
            
            return {"status": "websocket_aborted", "message": "WebSocket connection terminated"}
        else:
            logger.info("‚úó No active WebSocket to abort")
            return {"status": "no_websocket", "message": "No active WebSocket connection"}
            
    except Exception as e:
        logger.error(f"Error aborting WebSocket: {e}")
        return {"status": "error", "message": "Failed to abort WebSocket: " + str(e))


@app.post("/api/cleanup_partial_files")
async def cleanup_partial_files():
    """Clean up any partial files from cancelled operations."""
    try:
        import os
        import glob
        
        cleaned_files = []
        
        # Check for partial map files (less than 1KB might be incomplete)
        maps_pattern = "data/maps/*.png"
        for file_path in glob.glob(maps_pattern):
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                if file_size < 1024:  # Less than 1KB, likely partial
                    os.remove(file_path)
                    cleaned_files.append(file_path)
                    logger.info(f"üßπ Cleaned partial map file: {file_path}")
        
        # Check for partial embedding files (less than 100 bytes might be incomplete)
        embeddings_pattern = "data/embeddings/*.json"
        for file_path in glob.glob(embeddings_pattern):
            if os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                if file_size < 100:  # Less than 100 bytes, likely partial
                    os.remove(file_path)
                    cleaned_files.append(file_path)
                    logger.info(f"üßπ Cleaned partial embeddings file: {file_path}")
        
        logger.info(f"üßπ Quick cleanup completed: {len(cleaned_files)} files removed")
        return {"status": "success", "files_cleaned": len(cleaned_files), "files": cleaned_files}
        
    except Exception as e:
        logger.warning(f"‚ö† Error during quick cleanup: {e}")
        return {"status": "completed", "message": "Cleanup completed with minor issues"}


@app.post("/api/fetch_session")
async def fetch_session(request: Request):
    """Fetch existing session from AWS server."""
    try:
        body = await request.json()
        session_id = body.get('session_id', '').strip()
        
        # Validate session ID format
        if not session_id or len(session_id) != 8 or not session_id.isalnum():
            raise HTTPException(status_code=400, detail="Invalid session ID format")
        
        # Start the fetch operation in background
        global active_tasks
        task = asyncio.create_task(_fetch_session_background(session_id))
        active_tasks[f'fetch_session_{session_id}'] = task
        
        return {"status": "started", "session_id": session_id}
        
    except Exception as e:
        logger.error(f"Error in fetch_session: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/progress")
async def get_progress():
    """Get current operation progress."""
    global progress_data
    
    # Check for discovery progress first
    if 'discovery' in progress_data:
        return progress_data['discovery']
    
    # Then check for other operations
    for operation in ['fetch_session', 'init_map', 'send_logs']:
        if operation in progress_data:
            return progress_data[operation]
    
    # Return latest progress data or idle state
    if progress_data:
        latest = list(progress_data.values())[-1]
        # Ensure it's a dict, not a string
        if isinstance(latest, str):
            return {"status": "complete", "progress": 100, "message": latest}
        return latest
    
    return {"status": "idle", "progress": 0, "message": ""}


async def _init_map_background(lat: float, lng: float, km: float, task_id: str):
    """Background task for map initialization."""
    global progress_data
    
    # Store original state for rollback
    original_state = state_manager.load_state()
    
    try:
        # DO NOT update state yet - wait until everything succeeds
        
        # Initialize progress
        progress_data['init_map'] = {
            "status": "running",
            "progress": 0,
            "message": "Starting mission preparation...",
            "task_id": task_id
        }
        
        # Initialize progress with real tracking
        
        # Progress callback function
        def update_progress(message, progress):
            logger.info(f"üìä Progress update: {progress}% - {message}")
            progress_data['init_map'].update({
                "progress": progress,
                "message": message
            })
        
        # Call actual init_map wrapper with progress callback
        logger.info(f"üöÄ Starting mission: {lat}, {lng}, {km}km")
        try:
            from src.device.init_map_wrapper import call_server_init_map
            
            # Update progress for connection attempt
            update_progress("Connecting to server...", 10)
            
            # Call the synchronous function in an executor to avoid blocking
            import asyncio
            import functools
            
            # Wrap the synchronous function to run in thread pool
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None, 
                functools.partial(
                    call_server_init_map,
                    lat=lat, 
                    lng=lng, 
                    meters=int(km * 1000),
                    server_url="http://ec2-16-171-238-14.eu-north-1.compute.amazonaws.com:5000"
                )
            )
            logger.info(f"‚úÖ Server call completed: success={result.get('success')}")
            
            # Simulate progress updates since the sync function doesn't provide them
            if result.get('success'):
                update_progress("Processing satellite data...", 50)
                await asyncio.sleep(0.5)  # Brief pause for UI
                update_progress("Generating embeddings...", 80)
                await asyncio.sleep(0.5)  # Brief pause for UI
                
        except Exception as e:
            logger.error(f"‚ùå Server call failed: {e}")
            result = {"success": False, "error": f"Connection failed: {e}"}
        
        if result.get('success'):
            # ATOMIC STATE UPDATE: Only update state after ALL operations succeed
            # This includes: data download, unzipping, storage, AND validation
            session_id = result.get('session_id', '')
            
            # Verify that all data was actually stored successfully
            map_file = Path(f"data/maps/{session_id}.png")
            embeddings_file = Path(f"data/embeddings/{session_id}.json")
            
            # If files are missing but we have a session_id, attempt a fetch-only fallback
            if session_id and (not map_file.exists() or not embeddings_file.exists()):
                try:
                    from src.device.init_map_wrapper import call_server_init_map
                    fallback = await call_server_init_map(
                        lat=lat,
                        lng=lng,
                        meters=int(km * 1000),
                        server_url="http://ec2-16-171-238-14.eu-north-1.compute.amazonaws.com:5000",
                        session_id=session_id,
                        progress_callback=lambda m, p: progress_data['init_map'].update({"message": m, "progress": max(progress_data['init_map'].get('progress', 0), p)}),
                        fetch_only=True
                    )
                    # Recompute file paths after fallback
                    map_file = Path(f"data/maps/{session_id}.png")
                    embeddings_file = Path(f"data/embeddings/{session_id}.json")
                except Exception as _:
                    pass

            if map_file.exists() and embeddings_file.exists():
                # TRANSACTION COMMIT: Update all state atomically
                state_manager.update_state(
                    lat=lat,
                    lng=lng,
                    km=km,
                    session_id=session_id
                )
                
                progress_data['init_map'] = {
                    "status": "complete",
                    "progress": 100,
                    "message": "Mission data ready!"
                }
                
                logger.info(f"‚úì TRANSACTION COMPLETED: State updated atomically for session {session_id}")
                
                # FRONTEND CLEANUP: Keep completion status for 3 seconds so UI can detect it
                await asyncio.sleep(3.0)  # Give frontend time to detect completion and hide progress
                if 'init_map' in progress_data:
                    del progress_data['init_map']
                if task_id in active_tasks:
                    del active_tasks[task_id]
                    
            else:
                # Data verification failed - clean up partial files and rollback
                logger.error(f"‚úó TRANSACTION FAILED: Data files missing for session {session_id}")
                logger.info(f"‚úì CLEANUP: Removing partial data files for session {session_id}")
                
                # Clean up any partial files
                try:
                    if map_file.exists():
                        map_file.unlink()
                        logger.info(f"‚úì Removed partial map file: {map_file}")
                    if embeddings_file.exists():
                        embeddings_file.unlink()
                        logger.info(f"‚úì Removed partial embeddings file: {embeddings_file}")
                except Exception as cleanup_error:
                    logger.warning(f"‚ö† Error during cleanup: {cleanup_error}")
                
                progress_data['init_map'] = {
                    "status": "error",
                    "progress": 0,
                    "message": "Data verification failed"
                }
                # State remains unchanged (rollback)
                
                # Keep error status for 3 seconds so frontend can detect it
                await asyncio.sleep(3.0)
                if 'init_map' in progress_data and progress_data['init_map'].get("status") == "error":
                    del progress_data['init_map']
                if task_id in active_tasks:
                    del active_tasks[task_id]
                
        else:
            # TRANSACTION ROLLBACK: Operation failed, state remains unchanged
            logger.error(f"‚úó TRANSACTION FAILED: {result.get('error', 'Unknown error')}")
            progress_data['init_map'] = {
                "status": "error",
                "progress": 0,
                "message": f"Initialization failed: {result.get('error', 'Unknown error')}"
            }
            # State deliberately NOT updated - remains at original values
            
            # Quick cleanup on error
            await asyncio.sleep(0.5)
            if 'init_map' in progress_data and progress_data['init_map'].get("status") == "error":
                del progress_data['init_map']
            if task_id in active_tasks:
                del active_tasks[task_id]
    
    except asyncio.CancelledError:
        # TRANSACTION ROLLBACK: Operation cancelled, restore original state
        logger.info(f"‚úó TRANSACTION CANCELLED: Init map task {task_id} was cancelled by user")
        logger.info(f"‚úì STATE ROLLBACK: Restoring original state")
        
        # Clean up any partial data files that might have been created
        logger.info("‚úì CLEANUP: Removing any partial data files from cancelled operation")
        try:
            data_dir = Path("data")
            if data_dir.exists():
                # Clean up any temporary zip files
                for temp_file in data_dir.glob("*_temp.zip"):
                    temp_file.unlink()
                    logger.info(f"‚úì Removed temp file: {temp_file}")
                
                # Clean up any partial session files (we don't know the session_id yet)
                # This is a safety cleanup for any partial files
                import time
                current_time = time.time()
                for maps_dir in (data_dir / "maps").glob("*.png"):
                    # Remove files created in the last 5 minutes that might be partial
                    if current_time - maps_dir.stat().st_mtime < 300:  # 5 minutes
                        logger.info(f"‚ö† Removing recent map file (might be partial): {maps_dir}")
                        maps_dir.unlink()
                
                for emb_dir in (data_dir / "embeddings").glob("*.json"):
                    if current_time - emb_dir.stat().st_mtime < 300:  # 5 minutes
                        logger.info(f"‚ö† Removing recent embeddings file (might be partial): {emb_dir}")
                        emb_dir.unlink()
        except Exception as cleanup_error:
            logger.warning(f"‚ö† Error during cancellation cleanup: {cleanup_error}")
        
        # State remains unchanged from original (automatic rollback)
        progress_data['init_map'] = {
            "status": "cancelled",
            "progress": 0,
            "message": "Cleaning up..."
        }
        
        # Brief delay to show cleanup message, then clear
        await asyncio.sleep(1)
        if 'init_map' in progress_data:
            del progress_data['init_map']
        
        # Clean up task
        if task_id in active_tasks:
            del active_tasks[task_id]
    
    except Exception as e:
        # TRANSACTION ROLLBACK: Unexpected error, restore original state
        logger.error(f"‚úó TRANSACTION FAILED: Unexpected error in init_map task {task_id}: {e}")
        logger.info(f"‚úì STATE ROLLBACK: Restoring original state")
        
        # State remains unchanged from original (automatic rollback)
        progress_data['init_map'] = {
            "status": "error",
            "progress": 0,
            "message": f"Error: {str(e)}"
        }
        
        # Clean up task
        if task_id in active_tasks:
            del active_tasks[task_id]


async def _discovery_background(task_id: str):
    """Background task for drone discovery."""
    global progress_data
    
    try:
        from listener import DroneListener
        
        # Initialize progress
        progress_data['discovery'] = {
            "status": "running",
            "progress": 0,
            "message": "Looking for other drones...",
            "timer": 30,
            "task_id": task_id
        }
        
        # Update state to idle during discovery

        
        # Start discovery using the listener
        listener = DroneListener()
        
        # Simulate discovery countdown
        for i in range(30, 0, -1):
            if asyncio.current_task().cancelled():
                raise asyncio.CancelledError()
            
            progress = int((30 - i) / 30 * 100)
            progress_data['discovery'].update({
                "progress": progress,
                "message": f"Looking for other drones... ({i}s remaining)",
                "timer": i
            })
            
            await asyncio.sleep(1)
        
        # Try to start discovery (this is a placeholder - would integrate with actual listener)
        # result = await listener.start_discovery()
        
        # For now, simulate no drones found
        result = None
        
        if result and result.get('session_id'):
            # Found another drone
            state_manager.update_state(
                session_id=result.get('session_id'),
                lat=result.get('lat'),
                lng=result.get('lng'),
                km=result.get('km'),
                status='ready'
            )
            progress_data['discovery'] = {
                "status": "complete",
                "progress": 100,
                "message": "Found other drone! Session data received.",
                "timer": 0
            }
        else:
            # No drones found - check if we have local data to determine status
            current_state = state_manager.load_state()
            session_id = current_state.get('session_id')
            
            # Check if we have actual map/embedding files for this session
            if session_id:
                map_file = Path(f"data/maps/{session_id}.png")
                embeddings_file = Path(f"data/embeddings/{session_id}.json")
                
                if not (map_file.exists() and embeddings_file.exists()):
                    # Session ID exists but no data files - reset to empty
                    state_manager.update_state(session_id='')
            
            progress_data['discovery'] = {
                "status": "complete",
                "progress": 100,
                "message": "No other drones found. Ready for manual setup.",
                "timer": 0
            }
            
            # Clean up discovery progress after a delay
            await asyncio.sleep(2)
            if 'discovery' in progress_data:
                del progress_data['discovery']
    
    except asyncio.CancelledError:
        # Discovery cancelled - check if we have local data to determine status
        current_state = state_manager.load_state()
        session_id = current_state.get('session_id')
        
        if session_id:
            map_file = Path(f"data/maps/{session_id}.png")
            embeddings_file = Path(f"data/embeddings/{session_id}.json")
            
            if not (map_file.exists() and embeddings_file.exists()):
                state_manager.update_state(session_id='')
        
        if 'discovery' in progress_data:
            del progress_data['discovery']
        
        logger.info("Discovery cancelled")
    
    except Exception as e:
        logger.error(f"Error in discovery background task: {e}")

        progress_data['discovery'] = {
            "status": "error",
            "progress": 0,
            "message": f"Discovery error: {str(e)}",
            "timer": 0
        }


async def _send_logs_background(task_id: str):
    """Background task for sending logs."""
    global progress_data
    
    try:
        # Initialize progress
        progress_data['send_logs'] = {
            "status": "running",
            "progress": 0,
            "message": "Preparing logs...",
            "task_id": task_id
        }
        
        # Check if logs directory exists
        logs_dir = Path("logs")
        if not logs_dir.exists() or not any(logs_dir.iterdir()):
            progress_data['send_logs'] = {
                "status": "complete",
                "progress": 100,
                "message": "No logs to send"
            }
            return
        
        # Simulate log processing
        progress_steps = [
            (20, "Compressing logs..."),
            (40, "Uploading to server..."),
            (70, "Verifying upload..."),
            (90, "Cleaning up..."),
            (100, "Logs sent successfully")
        ]
        
        for progress, message in progress_steps:
            if asyncio.current_task().cancelled():
                raise asyncio.CancelledError()
            
            progress_data['send_logs'].update({
                "progress": progress,
                "message": message
            })
            
            await asyncio.sleep(1)  # Simulate work
        
        # TODO: Implement actual log upload to AWS server
        # For now, just simulate success and clean up logs
        
        # Clean up logs on success
        if logs_dir.exists():
            shutil.rmtree(logs_dir)
            logs_dir.mkdir(exist_ok=True)
        
        progress_data['send_logs'] = {
            "status": "complete",
            "progress": 100,
            "message": "Logs sent and cleaned up"
        }
    
    except asyncio.CancelledError:
        logger.info(f"Send logs task {task_id} was cancelled by user")
        progress_data['send_logs'] = {
            "status": "cancelled",
            "progress": 0,
            "message": "Cleaning up..."
        }
        
        # Brief delay to show cleanup message, then clear
        await asyncio.sleep(1)
        if 'send_logs' in progress_data:
            del progress_data['send_logs']
    
    except Exception as e:
        logger.error(f"Error in send_logs background task: {e}")
        progress_data['send_logs'] = {
            "status": "error",
            "progress": 0,
            "message": f"Error: {str(e)}"
        }


async def _fetch_session_background(session_id: str):
    """Background task to fetch existing session data from AWS server."""
    task_id = f"fetch_session_{session_id}"
    
    try:
        logger.info(f"Starting fetch session background task for session: {session_id}")
        
        # Initialize progress
        progress_data['fetch_session'] = {
            "status": "running",
            "progress": 0,
            "message": "Connecting to server..."
        }
        
        # Import the wrapper function
        from src.device.init_map_wrapper import call_server_init_map
        
        # Try to fetch using existing session
        try:
            # Use dummy coordinates since we're fetching existing data
            lat, lng, km = 0.0, 0.0, 1
            
            # Update progress manually since sync function doesn't provide callbacks
            progress_data['fetch_session']['message'] = "Connecting to server..."
            progress_data['fetch_session']['progress'] = 20
            
            # Call the synchronous function in an executor to avoid blocking
            import asyncio
            import functools
            
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None, 
                functools.partial(
                    call_server_init_map,
                    lat=lat, 
                    lng=lng, 
                    meters=km,
                    server_url="http://ec2-16-171-238-14.eu-north-1.compute.amazonaws.com:5000",
                    session_id=session_id
                )
            )
            
            if not result.get('success', True):  # Check for success=False
                error_msg = result.get('error', result.get('message', 'Failed to fetch session'))
                if 'not found' in error_msg.lower() or 'does not exist' in error_msg.lower():
                    progress_data['fetch_session'] = {
                        "status": "error",
                        "progress": 0,
                        "message": "Session not found"
                    }
                else:
                    progress_data['fetch_session'] = {
                        "status": "error", 
                        "progress": 0,
                        "message": error_msg
                    }
                return
            
            # Update state with fetched session
            state_manager.update_state(
                lat=result.get('lat', lat),
                lng=result.get('lng', lng), 
                km=result.get('km', km),
                session_id=session_id
            )
            
            # Success - show completion first
            progress_data['fetch_session'] = {
                "status": "complete",
                "progress": 100,
                "message": "Session data ready!"
            }
            
            # Brief delay to let frontend show completion, then clean up
            await asyncio.sleep(2.0)  # Give enough time for frontend to catch completion
            if 'fetch_session' in progress_data:
                del progress_data['fetch_session']
                
        except Exception as e:
            error_msg = str(e)
            if 'not found' in error_msg.lower() or '404' in error_msg:
                progress_data['fetch_session'] = {
                    "status": "error",
                    "progress": 0,
                    "message": "Session not found"
                }
            else:
                progress_data['fetch_session'] = {
                    "status": "error",
                    "progress": 0, 
                    "message": f"Network error: {error_msg}"
                }
    
    except asyncio.CancelledError:
        logger.info("Fetch session task cancelled")
        progress_data['fetch_session'] = {
            "status": "cancelled",
            "progress": 0,
            "message": "Fetch cancelled"
        }
        await asyncio.sleep(1)
        if 'fetch_session' in progress_data:
            del progress_data['fetch_session']
    
    except Exception as e:
        logger.error(f"Error in fetch session background task: {e}")
        progress_data['fetch_session'] = {
            "status": "error",
            "progress": 0,
            "message": f"Error: {str(e)}"
        }
    
    finally:
        # Clean up active task
        global active_tasks
        task_key = f'fetch_session_{session_id}'
        if task_key in active_tasks:
            del active_tasks[task_key]


if __name__ == "__main__":
    import uvicorn
    
    # Create necessary directories
    for directory in ["data", "data/maps", "data/embeddings", "logs"]:
        Path(directory).mkdir(parents=True, exist_ok=True)
    
    print("Starting Drone Device Server...")
    print("Access the web interface at: http://localhost:8888")
    
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=8888, 
        log_level="info",
        timeout_keep_alive=300,  # 5 minutes keep-alive for long operations
        timeout_graceful_shutdown=30
    )
